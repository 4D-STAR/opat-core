<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>opatIO-cpp: opat::lattice::TableLattice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">opatIO-cpp<span id="projectnumber">&#160;0.0.1a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classopat_1_1lattice_1_1_table_lattice.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classopat_1_1lattice_1_1_table_lattice-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">opat::lattice::TableLattice Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a lattice structure for interpolating data from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="table_lattice_8h_source.html">tableLattice.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d79d8e8d3dcf8b1cb32ce1bfa785a06" id="r_a2d79d8e8d3dcf8b1cb32ce1bfa785a06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d79d8e8d3dcf8b1cb32ce1bfa785a06">TableLattice</a> (const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> &amp;opat)</td></tr>
<tr class="memdesc:a2d79d8e8d3dcf8b1cb32ce1bfa785a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> object from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object.  <br /></td></tr>
<tr class="separator:a2d79d8e8d3dcf8b1cb32ce1bfa785a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3263cb2a7a8e183975655517d4eb6" id="r_a77e3263cb2a7a8e183975655517d4eb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e3263cb2a7a8e183975655517d4eb6">TableLattice</a> (const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> &amp;opat, const <a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a> &amp;interpolationType)</td></tr>
<tr class="memdesc:a77e3263cb2a7a8e183975655517d4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> object from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object with a specified interpolation type.  <br /></td></tr>
<tr class="separator:a77e3263cb2a7a8e183975655517d4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0a22897779221d828a93d2f8c415ed" id="r_aaf0a22897779221d828a93d2f8c415ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf0a22897779221d828a93d2f8c415ed">TableLattice</a> (const <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;)=default</td></tr>
<tr class="separator:aaf0a22897779221d828a93d2f8c415ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ea07a6a60e687458754b128f8781c9" id="r_ac0ea07a6a60e687458754b128f8781c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ea07a6a60e687458754b128f8781c9">operator=</a> (const <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;)=delete</td></tr>
<tr class="separator:ac0ea07a6a60e687458754b128f8781c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacbb67a33be347b8cc8a5f4ea51046a" id="r_abacbb67a33be347b8cc8a5f4ea51046a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abacbb67a33be347b8cc8a5f4ea51046a">TableLattice</a> (<a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:abacbb67a33be347b8cc8a5f4ea51046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb63ee11f941117e7f2ea4e417ff971" id="r_a9bb63ee11f941117e7f2ea4e417ff971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb63ee11f941117e7f2ea4e417ff971">operator=</a> (<a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&amp;) noexcept=delete</td></tr>
<tr class="separator:a9bb63ee11f941117e7f2ea4e417ff971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211417a765057c1b17f31b5c1b83e6cd" id="r_a211417a765057c1b17f31b5c1b83e6cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a211417a765057c1b17f31b5c1b83e6cd">~TableLattice</a> ()=default</td></tr>
<tr class="separator:a211417a765057c1b17f31b5c1b83e6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf44ee3968ddfa17c058aa5625599d3" id="r_a5bf44ee3968ddfa17c058aa5625599d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopat_1_1_data_card.html">DataCard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf44ee3968ddfa17c058aa5625599d3">get</a> (const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;indexVector) const</td></tr>
<tr class="memdesc:a5bf44ee3968ddfa17c058aa5625599d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves interpolated data for a given index vector.  <br /></td></tr>
<tr class="separator:a5bf44ee3968ddfa17c058aa5625599d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb8d66e89f3e556f9c01357346c34f7" id="r_adbb8d66e89f3e556f9c01357346c34f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb8d66e89f3e556f9c01357346c34f7">getInterpolationType</a> () const</td></tr>
<tr class="memdesc:adbb8d66e89f3e556f9c01357346c34f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current interpolation type.  <br /></td></tr>
<tr class="separator:adbb8d66e89f3e556f9c01357346c34f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93966812707e3168773fcd1eb559c928" id="r_a93966812707e3168773fcd1eb559c928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93966812707e3168773fcd1eb559c928">setInterpolationType</a> (<a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a> interpolationType)</td></tr>
<tr class="memdesc:a93966812707e3168773fcd1eb559c928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interpolation type.  <br /></td></tr>
<tr class="separator:a93966812707e3168773fcd1eb559c928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151c70742ccf550be4287324c423ffad" id="r_a151c70742ccf550be4287324c423ffad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151c70742ccf550be4287324c423ffad">dumpTriangulationToAscii</a> (const std::string &amp;points_file, const std::string &amp;simplices_file) const</td></tr>
<tr class="memdesc:a151c70742ccf550be4287324c423ffad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the Delaunay triangulation to ASCII files.  <br /></td></tr>
<tr class="separator:a151c70742ccf550be4287324c423ffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1be0b0b123b4e25db09e55c58f3b8ba8" id="r_a1be0b0b123b4e25db09e55c58f3b8ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be0b0b123b4e25db09e55c58f3b8ba8">initialize</a> ()</td></tr>
<tr class="memdesc:a1be0b0b123b4e25db09e55c58f3b8ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> internal structures.  <br /></td></tr>
<tr class="separator:a1be0b0b123b4e25db09e55c58f3b8ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dd715de3b0af74f0d937f65d8b586b" id="r_a31dd715de3b0af74f0d937f65d8b586b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31dd715de3b0af74f0d937f65d8b586b">buildDelaunay</a> ()</td></tr>
<tr class="memdesc:a31dd715de3b0af74f0d937f65d8b586b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the Delaunay triangulation of the index vectors.  <br /></td></tr>
<tr class="separator:a31dd715de3b0af74f0d937f65d8b586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2fd862721a8c8c4c6e73aeb2ca99f" id="r_a5ae2fd862721a8c8c4c6e73aeb2ca99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopat_1_1lattice_1_1_simplex.html">Simplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae2fd862721a8c8c4c6e73aeb2ca99f">findContainingSimplex</a> (const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;indexVector) const</td></tr>
<tr class="memdesc:a5ae2fd862721a8c8c4c6e73aeb2ca99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the simplex containing the given index vector using a walk algorithm.  <br /></td></tr>
<tr class="separator:a5ae2fd862721a8c8c4c6e73aeb2ca99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6765e24c4ccdd50e714ca6ed4296cc" id="r_a1d6765e24c4ccdd50e714ca6ed4296cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6765e24c4ccdd50e714ca6ed4296cc">validateIndexVector</a> (const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;indexVector) const</td></tr>
<tr class="memdesc:a1d6765e24c4ccdd50e714ca6ed4296cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates if the given index vector is within the global bounds of the table and has the correct dimension.  <br /></td></tr>
<tr class="separator:a1d6765e24c4ccdd50e714ca6ed4296cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f568c58bdfa5e6e179957dfe6564a6" id="r_ac8f568c58bdfa5e6e179957dfe6564a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f568c58bdfa5e6e179957dfe6564a6">calculateBarycentricWeights</a> (const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;queryPoint, const std::vector&lt; <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &gt; &amp;simplexActualVertices) const</td></tr>
<tr class="memdesc:ac8f568c58bdfa5e6e179957dfe6564a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the barycentric weights of a query point with respect to the vertices of a given simplex.  <br /></td></tr>
<tr class="separator:ac8f568c58bdfa5e6e179957dfe6564a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1e61aec5bc56743b260a4f91a240df6a" id="r_a1e61aec5bc56743b260a4f91a240df6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e61aec5bc56743b260a4f91a240df6a">m_opat</a></td></tr>
<tr class="memdesc:a1e61aec5bc56743b260a4f91a240df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object.  <br /></td></tr>
<tr class="separator:a1e61aec5bc56743b260a4f91a240df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9a29ae55f676a9dbde363e0ebf1e58" id="r_a4b9a29ae55f676a9dbde363e0ebf1e58"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b9a29ae55f676a9dbde363e0ebf1e58">m_indexVectorSize</a> {}</td></tr>
<tr class="memdesc:a4b9a29ae55f676a9dbde363e0ebf1e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality of the index vectors.  <br /></td></tr>
<tr class="separator:a4b9a29ae55f676a9dbde363e0ebf1e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2b5500096577a779ddee895cf283f6" id="r_a3d2b5500096577a779ddee895cf283f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d2b5500096577a779ddee895cf283f6">m_interpolationType</a> {<a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b">InterpolationType::Linear</a>}</td></tr>
<tr class="memdesc:a3d2b5500096577a779ddee895cf283f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of interpolation to use.  <br /></td></tr>
<tr class="separator:a3d2b5500096577a779ddee895cf283f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38150adf44ff2b4d169d3f733bcc2fa7" id="r_a38150adf44ff2b4d169d3f733bcc2fa7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38150adf44ff2b4d169d3f733bcc2fa7">m_indexVectors</a></td></tr>
<tr class="memdesc:a38150adf44ff2b4d169d3f733bcc2fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all unique index vectors from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file, serving as the vertices of the triangulation.  <br /></td></tr>
<tr class="separator:a38150adf44ff2b4d169d3f733bcc2fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751efc496be39e19e6b861c110394b3d" id="r_a751efc496be39e19e6b861c110394b3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a751efc496be39e19e6b861c110394b3d">m_axisValues</a></td></tr>
<tr class="memdesc:a751efc496be39e19e6b861c110394b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the unique values for each axis/dimension (Not currently used by Delaunay approach).  <br /></td></tr>
<tr class="separator:a751efc496be39e19e6b861c110394b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f1b9a40c628d8dcd445090233f06f1" id="r_a84f1b9a40c628d8dcd445090233f06f1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f1b9a40c628d8dcd445090233f06f1">m_numCorners</a> {}</td></tr>
<tr class="memdesc:a84f1b9a40c628d8dcd445090233f06f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of corners in a hypercube (2^m_indexVectorSize), relevant for hypercube-based approaches (not Delaunay).  <br /></td></tr>
<tr class="separator:a84f1b9a40c628d8dcd445090233f06f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad73eb1691d71b3ab29442c01e3800e5" id="r_aad73eb1691d71b3ab29442c01e3800e5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad73eb1691d71b3ab29442c01e3800e5">m_simplices</a></td></tr>
<tr class="memdesc:aad73eb1691d71b3ab29442c01e3800e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the simplices of the Delaunay triangulation. Each inner vector is a list of global vertex indices (indices into <code>m_indexVectors</code>).  <br /></td></tr>
<tr class="separator:aad73eb1691d71b3ab29442c01e3800e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e532863278e169f5518075d996fd3a" id="r_ac0e532863278e169f5518075d996fd3a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0e532863278e169f5518075d996fd3a">m_simplexAdjacency</a></td></tr>
<tr class="memdesc:ac0e532863278e169f5518075d996fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency list for simplices. <code>m_simplexAdjacency[i][j]</code> stores the ID of the simplex adjacent to simplex <code>i</code> across the face opposite to its <code>j</code>-th local vertex. A value of <code>static_cast&lt;std::size_t&gt;(-1)</code> indicates no neighbor (boundary).  <br /></td></tr>
<tr class="separator:ac0e532863278e169f5518075d996fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cecd333a28a005c370a991dba79fdc" id="r_aa3cecd333a28a005c370a991dba79fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopat_1_1lattice_1_1_simplex.html">Simplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3cecd333a28a005c370a991dba79fdc">m_lastFoundSimplex</a></td></tr>
<tr class="memdesc:aa3cecd333a28a005c370a991dba79fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the last found simplex (ID and barycentric weights) as a starting point for the <code>findContainingSimplex</code> walk algorithm, optimizing searches for spatially coherent query points. Initialized with an invalid ID.  <br /></td></tr>
<tr class="separator:aa3cecd333a28a005c370a991dba79fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a lattice structure for interpolating data from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object. </p>
<p>The <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> class builds a Delaunay triangulation of the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> index points and provides methods to interpolate data for a given index vector.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span>       <span class="comment">// For opat::readOPAT, opat::OPAT, opat::DataCard</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="index_vector_8h.html">indexVector.h</a>&quot;</span>  <span class="comment">// For FloatIndexVector</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="table_lattice_8h.html">tableLattice.h</a>&quot;</span> <span class="comment">// For opat::lattice::TableLattice</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Define the path to your OPAT file</span></div>
<div class="line">    std::string opat_filename = <span class="stringliteral">&quot;gs98Hz.opat&quot;</span>; <span class="comment">// Replace with your actual file path</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Load the OPAT file</span></div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> opat_data = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(opat_filename);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully loaded OPAT file: &quot;</span> &lt;&lt; opat_filename &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Create a TableLattice object from the loaded OPAT data</span></div>
<div class="line">    <span class="comment">// This will automatically build the Delaunay triangulation.</span></div>
<div class="line">    <span class="comment">// Default interpolation is Linear. (Also the only one currently implemented)</span></div>
<div class="line">    <a class="code hl_class" href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a> <a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>(opat_data);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TableLattice initialized.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optionally, set a different interpolation type (not yet implemented)</span></div>
<div class="line">    <span class="comment">// lattice.setInterpolationType(opat::lattice::InterpolationType::Quadratic);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Define an index vector for which you want to interpolate data.</span></div>
<div class="line">    <span class="comment">// The dimension of this vector must match opat_data.header.numIndex.</span></div>
<div class="line">    <span class="comment">// For this example, let&#39;s assume a 2D OPAT file, and we want data for (0.54421, 0.077585).</span></div>
<div class="line">    <a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> query_point({0.54421, 0.077585});</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Querying for index vector: &quot;</span> &lt;&lt; query_point &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Get the interpolated DataCard for the query_point.</span></div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_data_card.html">opat::DataCard</a> interpolated_card = <a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>.get(query_point);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Access a specific table from the interpolated DataCard.</span></div>
<div class="line">    std::string target_table_tag = <span class="stringliteral">&quot;data&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structopat_1_1_o_p_a_t_table.html">opat::OPATTable</a>&amp; interpolated_table = interpolated_card[target_table_tag];</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully accessed interpolated table: &quot;</span> &lt;&lt; target_table_tag &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can now use the interpolated_table, e.g., print it or extract values</span></div>
<div class="line">    <span class="comment">// interpolated_table.print();</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example of dumping the triangulation (useful for debugging)</span></div>
<div class="line">    <span class="comment">// lattice.dumpTriangulationToAscii(&quot;points_dump.txt&quot;, &quot;simplices_dump.txt&quot;);</span></div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Triangulation dumped to files.&quot; &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_float_index_vector_html"><div class="ttname"><a href="class_float_index_vector.html">FloatIndexVector</a></div><div class="ttdef"><b>Definition</b> indexVector.h:38</div></div>
<div class="ttc" id="aclassopat_1_1lattice_1_1_table_lattice_html"><div class="ttname"><a href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a></div><div class="ttdoc">Represents a lattice structure for interpolating data from an OPAT object.</div><div class="ttdef"><b>Definition</b> tableLattice.h:110</div></div>
<div class="ttc" id="aindex_vector_8h_html"><div class="ttname"><a href="index_vector_8h.html">indexVector.h</a></div><div class="ttdoc">Header file defining the FloatIndexVector class for handling floating-point index vectors.</div></div>
<div class="ttc" id="anamespaceopat_1_1lattice_html"><div class="ttname"><a href="namespaceopat_1_1lattice.html">opat::lattice</a></div><div class="ttdoc">Namespace for table lattice interpolation of OPAT files.</div><div class="ttdef"><b>Definition</b> tableLattice.cpp:28</div></div>
<div class="ttc" id="anamespaceopat_html_aca57fce2c7ef3e4714709b3d9507d4b0"><div class="ttname"><a href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a></div><div class="ttdeci">OPAT readOPAT(const std::string &amp;filename)</div><div class="ttdoc">Reads an OPAT file and returns its contents as an OPAT structure.</div><div class="ttdef"><b>Definition</b> opatIO.cpp:76</div></div>
<div class="ttc" id="aopat_i_o_8h_html"><div class="ttname"><a href="opat_i_o_8h.html">opatIO.h</a></div><div class="ttdoc">Header file for the OPAT I/O library, providing structures and functions for reading and manipulating...</div></div>
<div class="ttc" id="astructopat_1_1_data_card_html"><div class="ttname"><a href="structopat_1_1_data_card.html">opat::DataCard</a></div><div class="ttdoc">Structure to hold a DataCard, which contains multiple tables.</div><div class="ttdef"><b>Definition</b> opatIO.h:409</div></div>
<div class="ttc" id="astructopat_1_1_o_p_a_t_html"><div class="ttname"><a href="structopat_1_1_o_p_a_t.html">opat::OPAT</a></div><div class="ttdoc">Structure to hold the entire OPAT file.</div><div class="ttdef"><b>Definition</b> opatIO.h:502</div></div>
<div class="ttc" id="astructopat_1_1_o_p_a_t_table_html"><div class="ttname"><a href="structopat_1_1_o_p_a_t_table.html">opat::OPATTable</a></div><div class="ttdoc">Structure to hold the data of an OPAT table.</div><div class="ttdef"><b>Definition</b> opatIO.h:259</div></div>
<div class="ttc" id="atable_lattice_8h_html"><div class="ttname"><a href="table_lattice_8h.html">tableLattice.h</a></div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2d79d8e8d3dcf8b1cb32ce1bfa785a06" name="a2d79d8e8d3dcf8b1cb32ce1bfa785a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d79d8e8d3dcf8b1cb32ce1bfa785a06">&#9670;&#160;</a></span>TableLattice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">opat::lattice::TableLattice::TableLattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> object from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object. </p>
<p>Initializes the lattice using the index vectors from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object and builds a Delaunay triangulation using Qhull. Defaults to Linear interpolation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opat</td><td>The <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object containing the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Delaunay triangulation construction fails (e.g., due to Qhull errors, which could be caused by insufficient or degenerate input points from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file). Resolution: Ensure the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file contains valid and sufficient index points for triangulation.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> my_opat_data = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(<span class="stringliteral">&quot;my_data.opat&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a> <a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>(my_opat_data);</div>
<div class="line"><span class="comment">// Use the lattice...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a77e3263cb2a7a8e183975655517d4eb6" name="a77e3263cb2a7a8e183975655517d4eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e3263cb2a7a8e183975655517d4eb6">&#9670;&#160;</a></span>TableLattice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opat::lattice::TableLattice::TableLattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>interpolationType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> object from an <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object with a specified interpolation type. </p>
<p>Initializes the lattice using the index vectors from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object and builds a Delaunay triangulation using Qhull. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opat</td><td>The <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object containing the data. </td></tr>
    <tr><td class="paramname">interpolationType</td><td>The type of interpolation to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the specified <code>interpolationType</code> is not <code><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b" title="Linear interpolation.">InterpolationType::Linear</a></code>, as other types are not yet implemented. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if Delaunay triangulation construction fails (e.g., due to Qhull errors, which could be caused by insufficient or degenerate input points from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file). Resolution: Ensure the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file contains valid and sufficient index points for triangulation. Use <code><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b" title="Linear interpolation.">InterpolationType::Linear</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> my_opat_data = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(<span class="stringliteral">&quot;my_data.opat&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a> <a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>(my_opat_data, <a class="code hl_enumvalue" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b">opat::lattice::InterpolationType::Linear</a>);</div>
<div class="line"><span class="comment">// Use the lattice</span></div>
<div class="ttc" id="anamespaceopat_1_1lattice_html_a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b"><div class="ttname"><a href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b">opat::lattice::InterpolationType::Linear</a></div><div class="ttdeci">@ Linear</div><div class="ttdoc">Linear interpolation.</div><div class="ttdef"><b>Definition</b> tableLattice.h:47</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaf0a22897779221d828a93d2f8c415ed" name="aaf0a22897779221d828a93d2f8c415ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0a22897779221d828a93d2f8c415ed">&#9670;&#160;</a></span>TableLattice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">opat::lattice::TableLattice::TableLattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abacbb67a33be347b8cc8a5f4ea51046a" name="abacbb67a33be347b8cc8a5f4ea51046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacbb67a33be347b8cc8a5f4ea51046a">&#9670;&#160;</a></span>TableLattice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">opat::lattice::TableLattice::TableLattice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a211417a765057c1b17f31b5c1b83e6cd" name="a211417a765057c1b17f31b5c1b83e6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211417a765057c1b17f31b5c1b83e6cd">&#9670;&#160;</a></span>~TableLattice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">opat::lattice::TableLattice::~TableLattice </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a31dd715de3b0af74f0d937f65d8b586b" name="a31dd715de3b0af74f0d937f65d8b586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dd715de3b0af74f0d937f65d8b586b">&#9670;&#160;</a></span>buildDelaunay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void opat::lattice::TableLattice::buildDelaunay </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the Delaunay triangulation of the index vectors. </p>
<p>Uses the Qhull library to perform Delaunay triangulation on the points stored in <code>m_indexVectors</code>. Populates <code>m_simplices</code> with the vertex indices of each simplex and <code>m_simplexAdjacency</code> with neighbor information. This method is called by the constructors after <code><a class="el" href="#a1be0b0b123b4e25db09e55c58f3b8ba8" title="Initializes the TableLattice internal structures.">initialize()</a></code>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>(wrapping <code>orgQhull::QhullError</code>) if Qhull encounters an error during triangulation. This can happen due to issues like insufficient points for the dimension, all points being collinear/coplanar in a way that prevents triangulation, or other Qhull internal errors. Resolution: Check the validity and distribution of index vectors in the input <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file. Ensure there are enough non-degenerate points for the given number of dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f568c58bdfa5e6e179957dfe6564a6" name="ac8f568c58bdfa5e6e179957dfe6564a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f568c58bdfa5e6e179957dfe6564a6">&#9670;&#160;</a></span>calculateBarycentricWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; opat::lattice::TableLattice::calculateBarycentricWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queryPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>simplexActualVertices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the barycentric weights of a query point with respect to the vertices of a given simplex. </p>
<p>Solves a linear system of equations to find the weights. The sum of barycentric weights is 1. If a point is inside a simplex, all its weights are non-negative. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPoint</td><td>The point for which to calculate barycentric weights. </td></tr>
    <tr><td class="paramname">simplexActualVertices</td><td>A vector of <code><a class="el" href="class_float_index_vector.html">FloatIndexVector</a></code> representing the coordinates of the simplex's vertices. The number of vertices must be <code>m_indexVectorSize + 1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <code>double</code> containing the barycentric weights. The order of weights corresponds to the order of vertices in <code>simplexActualVertices</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>simplexActualVertices</code> does not contain <code>m_indexVectorSize + 1</code> vertices, or if <code>queryPoint</code> or any vertex in <code>simplexActualVertices</code> does not have <code>m_indexVectorSize</code> dimensions. Resolution: Ensure input vectors have correct sizes and dimensions matching the lattice. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>solveLinearSystem</code> fails, typically because the matrix formed by simplex vertices is singular (e.g., degenerate simplex - vertices are collinear/coplanar). Resolution: This indicates an issue with the geometry of the provided simplex vertices. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <code>solveLinearSystem</code> returns an unexpected number of solution components. Resolution: This indicates an internal logic error in the linear solver or its usage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a151c70742ccf550be4287324c423ffad" name="a151c70742ccf550be4287324c423ffad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151c70742ccf550be4287324c423ffad">&#9670;&#160;</a></span>dumpTriangulationToAscii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opat::lattice::TableLattice::dumpTriangulationToAscii </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>points_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>simplices_file</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the Delaunay triangulation to ASCII files. </p>
<p>Creates two files: one for the points (vertices) and one for the simplices. This is useful for visualizing or debugging the triangulation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points_file</td><td>The path to the file where points will be saved. </td></tr>
    <tr><td class="paramname">simplices_file</td><td>The path to the file where simplices will be saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>if an error occurs during file I/O operations (e.g., cannot open file for writing). Resolution: Ensure the program has write permissions to the specified file paths and that the paths are valid.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="comment">// Assuming &#39;lattice&#39; is an initialized TableLattice object</span></div>
<div class="line"><a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>.dumpTriangulationToAscii(<span class="stringliteral">&quot;my_points.txt&quot;</span>, <span class="stringliteral">&quot;my_simplices.txt&quot;</span>);</div>
<div class="line"><span class="comment">// This will create two files:</span></div>
<div class="line"><span class="comment">// &quot;my_points.txt&quot; containing the coordinates of the triangulation vertices.</span></div>
<div class="line"><span class="comment">// &quot;my_simplices.txt&quot; containing the vertex indices for each simplex.</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5ae2fd862721a8c8c4c6e73aeb2ca99f" name="a5ae2fd862721a8c8c4c6e73aeb2ca99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2fd862721a8c8c4c6e73aeb2ca99f">&#9670;&#160;</a></span>findContainingSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopat_1_1lattice_1_1_simplex.html">Simplex</a> opat::lattice::TableLattice::findContainingSimplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indexVector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the simplex containing the given index vector using a walk algorithm. </p>
<p>Starts from a known simplex (potentially the last found one, <code>m_lastFoundSimplex</code>) and "walks" through adjacent simplices until the one containing the <code>indexVector</code> is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexVector</td><td>The index vector to locate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structopat_1_1lattice_1_1_simplex.html" title="Represents a simplex containing a point, along with barycentric weights.">Simplex</a></code> struct containing the ID of the simplex and the barycentric weights of the <code>indexVector</code> within it. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>validateIndexVector</code> fails (point outside overall bounds), or if the walk terminates at the convex hull and the point is determined to be outside. Also thrown for internal out-of-bounds access to <code>m_simplices</code>, <code>m_indexVectors</code>, or <code>m_simplexAdjacency</code>. Resolution: Ensure <code>indexVector</code> is within the data bounds and convex hull. Internal errors suggest issues with triangulation data. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>validateIndexVector</code> fails (dimension mismatch) or if <code>indexVector</code> dimension doesn't match <code>m_indexVectorSize</code> during the walk. Resolution: Ensure <code>indexVector</code> has the correct number of dimensions. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the triangulation is empty (<code>m_simplices.empty()</code>), if a cycle is detected during the walk, if the walk cannot determine an exit face from a simplex, if the maximum number of walk steps is exceeded, or if <code>calculateBarycentricWeights</code> fails (e.g. degenerate simplex). Resolution: These often indicate issues with the triangulation's integrity, adjacency information, numerical precision challenges, or a query point far outside the domain leading to extended walks. Verify the input <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> data. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>from <code>calculateBarycentricWeights</code> if an unexpected number of weights is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bf44ee3968ddfa17c058aa5625599d3" name="a5bf44ee3968ddfa17c058aa5625599d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf44ee3968ddfa17c058aa5625599d3">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopat_1_1_data_card.html">DataCard</a> opat::lattice::TableLattice::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indexVector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves interpolated data for a given index vector. </p>
<p>Finds the containing simplex for the index vector and performs barycentric interpolation of the data from the simplex vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexVector</td><td>The index vector for which to interpolate data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structopat_1_1_data_card.html" title="Structure to hold a DataCard, which contains multiple tables.">DataCard</a> containing the interpolated data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the <code>indexVector</code> is outside the bounds of the table data (as determined by <code>validateIndexVector</code>), or if <code>findContainingSimplex</code> determines the point is outside the convex hull of the data points, or if an internal ID (vertex/simplex) is out of bounds. Resolution: Ensure <code>indexVector</code> values are within the min/max range for each dimension (check <code><a class="el" href="structopat_1_1_o_p_a_t.html#aa11de0c3d51e4ee48526a0b2295f017c" title="Calculates and returns the bounds (min and max values) for each dimension of the index vectors in the...">opat::OPAT::getBounds()</a></code>). Ensure the point lies within the convex hull of the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> index points. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the <code>indexVector</code> has a dimension different from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> data's index dimension (checked by <code>validateIndexVector</code> or <code>findContainingSimplex</code>). Resolution: Ensure <code>indexVector.size()</code> matches <code>opat_object.header.numIndex</code>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>findContainingSimplex</code> fails due to internal errors (e.g., no simplices, cycle in walk, cannot determine exit face, max walk steps reached), or if <code>calculateBarycentricWeights</code> fails due to a degenerate simplex (singular matrix). Resolution: These errors often indicate issues with the underlying triangulation or extreme numerical conditions. Verify the integrity of the input <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file's index data. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <code>calculateBarycentricWeights</code> returns an unexpected number of weights (internal logic error).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="comment">// Assuming &#39;lattice&#39; is an initialized TableLattice object</span></div>
<div class="line"><span class="comment">// and &#39;my_opat_object&#39; is the OPAT object it was built from.</span></div>
<div class="line"><span class="comment">// For an OPAT with 2 index dimensions:</span></div>
<div class="line"><a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> target_iv({0.25, 0.75});</div>
<div class="line"><a class="code hl_struct" href="structopat_1_1_data_card.html">opat::DataCard</a> result = <a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>.get(target_iv);</div>
<div class="line"><span class="comment">// Use &#39;result&#39; which contains interpolated data</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adbb8d66e89f3e556f9c01357346c34f7" name="adbb8d66e89f3e556f9c01357346c34f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb8d66e89f3e556f9c01357346c34f7">&#9670;&#160;</a></span>getInterpolationType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a> opat::lattice::TableLattice::getInterpolationType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current interpolation type. </p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605" title="Defines the type of interpolation to be used.">InterpolationType</a>. </dd></dl>

</div>
</div>
<a id="a1be0b0b123b4e25db09e55c58f3b8ba8" name="a1be0b0b123b4e25db09e55c58f3b8ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be0b0b123b4e25db09e55c58f3b8ba8">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void opat::lattice::TableLattice::initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html" title="Represents a lattice structure for interpolating data from an OPAT object.">TableLattice</a> internal structures. </p>
<p>Extracts unique index vectors from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object and stores them in <code>m_indexVectors</code>. Sets <code>m_indexVectorSize</code> based on <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> header. This method is called by the constructors. </p>

</div>
</div>
<a id="ac0ea07a6a60e687458754b128f8781c9" name="ac0ea07a6a60e687458754b128f8781c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ea07a6a60e687458754b128f8781c9">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp; opat::lattice::TableLattice::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bb63ee11f941117e7f2ea4e417ff971" name="a9bb63ee11f941117e7f2ea4e417ff971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb63ee11f941117e7f2ea4e417ff971">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp; opat::lattice::TableLattice::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93966812707e3168773fcd1eb559c928" name="a93966812707e3168773fcd1eb559c928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93966812707e3168773fcd1eb559c928">&#9670;&#160;</a></span>setInterpolationType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opat::lattice::TableLattice::setInterpolationType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a></td>          <td class="paramname"><span class="paramname"><em>interpolationType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interpolation type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolationType</td><td>The new <a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605" title="Defines the type of interpolation to be used.">InterpolationType</a> to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>interpolationType</code> is not <code><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b" title="Linear interpolation.">InterpolationType::Linear</a></code>, as other types are not currently implemented. Resolution: Only use <code><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b" title="Linear interpolation.">InterpolationType::Linear</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="comment">// Assuming &#39;lattice&#39; is an initialized TableLattice object</span></div>
<div class="line"><a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>.setInterpolationType(<a class="code hl_enumvalue" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b">opat::lattice::InterpolationType::Linear</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1d6765e24c4ccdd50e714ca6ed4296cc" name="a1d6765e24c4ccdd50e714ca6ed4296cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6765e24c4ccdd50e714ca6ed4296cc">&#9670;&#160;</a></span>validateIndexVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void opat::lattice::TableLattice::validateIndexVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indexVector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates if the given index vector is within the global bounds of the table and has the correct dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexVector</td><td>The index vector to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>indexVector.size()</code> does not match <code>m_opat.header.numIndex</code>. Resolution: Ensure the query <code>indexVector</code> has the same number of dimensions as the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> data. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if any component of <code>indexVector</code> is outside the min/max bounds defined by <code>m_opat.getBounds()</code> for that dimension. Resolution: Ensure all components of the <code>indexVector</code> are within the established bounds of the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> data.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="comment">// Assuming &#39;lattice&#39; is an initialized TableLattice object</span></div>
<div class="line"><span class="comment">// and &#39;opat_data&#39; is the OPAT object it was built from.</span></div>
<div class="line"><a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> valid_point({0.5, 0.5}); <span class="comment">// Assuming 2D and bounds contain this</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_namespace" href="namespaceopat_1_1lattice.html">lattice</a>.validateIndexVector(valid_point); <span class="comment">// Should pass</span></div>
<div class="line"><span class="comment">// lattice.validateIndexVector(FloatIndexVector({0.5})); // Would throw std::invalid_argument if numIndex != 1</span></div>
<div class="line"><span class="comment">// lattice.validateIndexVector(FloatIndexVector({100.0, 100.0})); // Would throw std::out_of_range if bounds are smaller</span></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a751efc496be39e19e6b861c110394b3d" name="a751efc496be39e19e6b861c110394b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751efc496be39e19e6b861c110394b3d">&#9670;&#160;</a></span>m_axisValues</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; opat::lattice::TableLattice::m_axisValues</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the unique values for each axis/dimension (Not currently used by Delaunay approach). </p>

</div>
</div>
<a id="a38150adf44ff2b4d169d3f733bcc2fa7" name="a38150adf44ff2b4d169d3f733bcc2fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38150adf44ff2b4d169d3f733bcc2fa7">&#9670;&#160;</a></span>m_indexVectors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_float_index_vector.html">FloatIndexVector</a>&gt; opat::lattice::TableLattice::m_indexVectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all unique index vectors from the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> file, serving as the vertices of the triangulation. </p>

</div>
</div>
<a id="a4b9a29ae55f676a9dbde363e0ebf1e58" name="a4b9a29ae55f676a9dbde363e0ebf1e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9a29ae55f676a9dbde363e0ebf1e58">&#9670;&#160;</a></span>m_indexVectorSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t opat::lattice::TableLattice::m_indexVectorSize {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dimensionality of the index vectors. </p>

</div>
</div>
<a id="a3d2b5500096577a779ddee895cf283f6" name="a3d2b5500096577a779ddee895cf283f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2b5500096577a779ddee895cf283f6">&#9670;&#160;</a></span>m_interpolationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605">InterpolationType</a> opat::lattice::TableLattice::m_interpolationType {<a class="el" href="namespaceopat_1_1lattice.html#a8e39ea4a5ca7b998812a84e72cae2605a32a843da6ea40ab3b17a3421ccdf671b">InterpolationType::Linear</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of interpolation to use. </p>

</div>
</div>
<a id="aa3cecd333a28a005c370a991dba79fdc" name="aa3cecd333a28a005c370a991dba79fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cecd333a28a005c370a991dba79fdc">&#9670;&#160;</a></span>m_lastFoundSimplex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopat_1_1lattice_1_1_simplex.html">Simplex</a> opat::lattice::TableLattice::m_lastFoundSimplex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel mutable">mutable</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the last found simplex (ID and barycentric weights) as a starting point for the <code>findContainingSimplex</code> walk algorithm, optimizing searches for spatially coherent query points. Initialized with an invalid ID. </p>

</div>
</div>
<a id="a84f1b9a40c628d8dcd445090233f06f1" name="a84f1b9a40c628d8dcd445090233f06f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f1b9a40c628d8dcd445090233f06f1">&#9670;&#160;</a></span>m_numCorners</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t opat::lattice::TableLattice::m_numCorners {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of corners in a hypercube (2^m_indexVectorSize), relevant for hypercube-based approaches (not Delaunay). </p>

</div>
</div>
<a id="a1e61aec5bc56743b260a4f91a240df6a" name="a1e61aec5bc56743b260a4f91a240df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61aec5bc56743b260a4f91a240df6a">&#9670;&#160;</a></span>m_opat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a>&amp; opat::lattice::TableLattice::m_opat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the <a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">OPAT</a> object. </p>

</div>
</div>
<a id="ac0e532863278e169f5518075d996fd3a" name="ac0e532863278e169f5518075d996fd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e532863278e169f5518075d996fd3a">&#9670;&#160;</a></span>m_simplexAdjacency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::size_t&gt; &gt; opat::lattice::TableLattice::m_simplexAdjacency</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjacency list for simplices. <code>m_simplexAdjacency[i][j]</code> stores the ID of the simplex adjacent to simplex <code>i</code> across the face opposite to its <code>j</code>-th local vertex. A value of <code>static_cast&lt;std::size_t&gt;(-1)</code> indicates no neighbor (boundary). </p>

</div>
</div>
<a id="aad73eb1691d71b3ab29442c01e3800e5" name="aad73eb1691d71b3ab29442c01e3800e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad73eb1691d71b3ab29442c01e3800e5">&#9670;&#160;</a></span>m_simplices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::size_t&gt; &gt; opat::lattice::TableLattice::m_simplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the simplices of the Delaunay triangulation. Each inner vector is a list of global vertex indices (indices into <code>m_indexVectors</code>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/public/<a class="el" href="table_lattice_8h_source.html">tableLattice.h</a></li>
<li>src/private/<a class="el" href="table_lattice_8cpp.html">tableLattice.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceopat.html">opat</a></li><li class="navelem"><a class="el" href="namespaceopat_1_1lattice.html">lattice</a></li><li class="navelem"><a class="el" href="classopat_1_1lattice_1_1_table_lattice.html">TableLattice</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
