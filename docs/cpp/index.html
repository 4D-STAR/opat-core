<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>opatIO-cpp: OPAT I/O Library Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">opatIO-cpp<span id="projectnumber">&#160;0.0.1a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">OPAT I/O Library Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2static_2mainpage"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>The <code>opatIO-cpp</code> library is a high-performance C++ library designed for reading, writing, and manipulating OPAT (Open Parameterized Array Table) files. These files are used to store structured numeric, in a compact and efficient format, indexed by some arbitrary length floating point vector. The library provides both programmatic and command-line interfaces, making it suitable for integration into larger software systems or for standalone data inspection and validation tasks.</p>
<p>Key features of <code>opatIO-cpp</code> include:</p><ul>
<li><b>C++ API</b>: A robust API for accessing and manipulating OPAT files programmatically.</li>
<li><b>Data Slicing</b>: Support for slicing tables by rows and columns for efficient data extraction.</li>
<li><b>Raw Data Access</b>: Direct access to raw data for advanced use cases.</li>
<li><b>CLI Tools</b>: Command-line utilities for inspecting, validating, and analyzing OPAT files.</li>
<li><b>Cross-Platform</b>: Compatible with major operating systems, including Linux, macOS, and Windows.</li>
<li><b>Performance</b>: Optimized for speed and low memory overhead, making it suitable for large datasets.</li>
</ul>
<p>The library is part of the broader OPAT ecosystem and is designed to work seamlessly with other tools and libraries in the OPAT suite.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Note</h2>
<p>The <code>opatIO-cpp</code> library is intended only for reading OPAT files. Writing OPAT files is not supported at this time. The library is designed to be fast and efficient, but it does not include all the features of the OPAT file format. For more advanced use cases, consider using the Python version of the library.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md4"></a>
Dependencies</h1>
<p>The <code>opatIO-cpp</code> project relies on several external libraries to provide its functionality. Understanding these dependencies can be helpful for development and troubleshooting.</p>
<ul>
<li><b>Boost</b>:<ul>
<li><b>Usage</b>: Primarily used in the <code>TableLattice</code> component for numerical linear algebra operations, specifically <code>boost::numeric::ublas::matrix</code> and <code>boost::numeric::ublas::vector</code> for solving systems of equations related to barycentric coordinate calculations.</li>
<li><b>Installation</b>: Boost is the only dependency that typically needs to be installed as a system library. However, the project includes a helper script (<code>build-config/boost/install.sh</code>) that can download and build Boost locally if it's not detected on your system. The Meson build system will prompt you before attempting to run this script.</li>
</ul>
</li>
<li><b>Qhull</b>:<ul>
<li><b>Usage</b>: Utilized by the <code>TableLattice</code> class to perform N-dimensional Delaunay triangulation of the OPAT index points, which is a core part of the interpolation mechanism.</li>
<li><b>Installation</b>: Qhull is managed via Meson's wrap system and is built automatically during the project's compilation if not found. No separate system installation is typically required.</li>
</ul>
</li>
<li><b>xxHash</b>:<ul>
<li><b>Usage</b>: A fast hashing algorithm used to find the hash of a <a class="el" href="class_float_index_vector.html">FloatIndexVector</a> for fast lookups in the <code>OPAT</code> class. This is crucial for efficiently accessing data in OPAT files.</li>
<li><b>Installation</b>: Managed via Meson's wrap system and built automatically.</li>
</ul>
</li>
<li><b>PicoSHA2</b>:<ul>
<li><b>Usage</b>: Used for generating SHA-256 hashes to validate data integrity.</li>
<li><b>Installation</b>: Managed via Meson's wrap system and built automatically.</li>
</ul>
</li>
<li><b>cxxopts</b>:<ul>
<li><b>Usage</b>: A lightweight C++ library for parsing command-line options. This is used by the command-line interface (CLI) tools provided with <code>opatIO-cpp</code> (e.g., <code>opatHeader</code>, <code>opatInspect</code>, <code>opatVerify</code>) to handle user-provided arguments.</li>
<li><b>Installation</b>: Managed via Meson's wrap system and built automatically.</li>
</ul>
</li>
</ul>
<p>In summary, for most users, only ensuring Boost is available (or allowing the build script to install it) is necessary. The other dependencies are handled seamlessly by the Meson build system.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md6"></a>
Installation</h1>
<p>You will need <code>meson</code>, <code>cmake</code>, and <code>ninja</code> installed pre-installed. These can be installed with pip </p><div class="fragment"><div class="line">pip install &quot;meson&gt;=1.6.0&quot;</div>
<div class="line">pip install cmake</div>
<div class="line">pip install ninja</div>
</div><!-- fragment --><p> Then you can build and install opat-core </p><div class="fragment"><div class="line">git clone https://github.com/4D-STAR/opat-core</div>
<div class="line">cd opat-core</div>
<div class="line">meson setup build --buildtype=release</div>
<div class="line">meson compile -C build</div>
</div><!-- fragment --><p> If you want to run tests </p><div class="fragment"><div class="line">meson test -C build</div>
</div><!-- fragment --><p> To install headers, libraries, and the command line utilities </p><div class="fragment"><div class="line">meson install -C build</div>
</div><!-- fragment --> <hr  />
<h1><a class="anchor" id="autotoc_md8"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
1. Programmatic (API) Usage</h2>
<p>The OPAT I/O library provides a C++ API for interacting with OPAT files. Below are some common use cases:</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Reading an OPAT File</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::string filename = <span class="stringliteral">&quot;example.opat&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> file = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(filename);</div>
<div class="line">    file.<a class="code hl_variable" href="structopat_1_1_o_p_a_t.html#a0c7a30f0a06bb0892f8b166378c80245">header</a>.<a class="code hl_function" href="structopat_1_1_header.html#af80325e25e93dfd6f3dc5938550a3236">print</a>(); <span class="comment">// Print the header information</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceopat_html_aca57fce2c7ef3e4714709b3d9507d4b0"><div class="ttname"><a href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a></div><div class="ttdeci">OPAT readOPAT(const std::string &amp;filename)</div><div class="ttdoc">Reads an OPAT file and returns its contents as an OPAT structure.</div><div class="ttdef"><b>Definition</b> opatIO.cpp:76</div></div>
<div class="ttc" id="aopat_i_o_8h_html"><div class="ttname"><a href="opat_i_o_8h.html">opatIO.h</a></div><div class="ttdoc">Header file for the OPAT I/O library, providing structures and functions for reading and manipulating...</div></div>
<div class="ttc" id="astructopat_1_1_header_html_af80325e25e93dfd6f3dc5938550a3236"><div class="ttname"><a href="structopat_1_1_header.html#af80325e25e93dfd6f3dc5938550a3236">opat::Header::print</a></div><div class="ttdeci">void print() const</div><div class="ttdoc">Prints the header information to the console.</div><div class="ttdef"><b>Definition</b> opatIO.cpp:257</div></div>
<div class="ttc" id="astructopat_1_1_o_p_a_t_html"><div class="ttname"><a href="structopat_1_1_o_p_a_t.html">opat::OPAT</a></div><div class="ttdoc">Structure to hold the entire OPAT file.</div><div class="ttdef"><b>Definition</b> opatIO.h:502</div></div>
<div class="ttc" id="astructopat_1_1_o_p_a_t_html_a0c7a30f0a06bb0892f8b166378c80245"><div class="ttname"><a href="structopat_1_1_o_p_a_t.html#a0c7a30f0a06bb0892f8b166378c80245">opat::OPAT::header</a></div><div class="ttdeci">Header header</div><div class="ttdoc">Header of the OPAT file.</div><div class="ttdef"><b>Definition</b> opatIO.h:503</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Accessing a Table by Index and Tag</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> file = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(<span class="stringliteral">&quot;example.opat&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> index({0.35, 0.004});</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table = file[index][<span class="stringliteral">&quot;data&quot;</span>];</div>
<div class="line">    table.print(); <span class="comment">// Print the table data</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_float_index_vector_html"><div class="ttname"><a href="class_float_index_vector.html">FloatIndexVector</a></div><div class="ttdef"><b>Definition</b> indexVector.h:38</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Slicing a Table</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> file = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(<span class="stringliteral">&quot;example.opat&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> index({0.35, 0.004});</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_slice.html">opat::Slice</a> rowSlice(0, 6);</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_slice.html">opat::Slice</a> colSlice(25, 36);</div>
<div class="line">    <span class="keyword">auto</span> slicedTable = file[index][<span class="stringliteral">&quot;data&quot;</span>].slice(rowSlice, colSlice);</div>
<div class="line">    slicedTable.print(); <span class="comment">// Print the sliced table</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructopat_1_1_slice_html"><div class="ttname"><a href="structopat_1_1_slice.html">opat::Slice</a></div><div class="ttdoc">Structure to represent a slice of data.</div><div class="ttdef"><b>Definition</b> opatIO.h:239</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
Retrieving Raw Data</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> file = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(<span class="stringliteral">&quot;example.opat&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> index({0.35, 0.004});</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>* rawData = file[index][<span class="stringliteral">&quot;data&quot;</span>].getRawData();</div>
<div class="line">    <span class="comment">// Use rawData as needed</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <hr  />
<h1><a class="anchor" id="autotoc_md15"></a>
Using <code>TableLattice</code> for Interpolation</h1>
<p>The <code>opatIO-cpp</code> library includes a powerful feature for interpolating data within OPAT files: the <code>TableLattice</code> class. This is particularly useful when you need to estimate data values at index points that are not explicitly defined in the OPAT file.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Theoretical Background</h2>
<p>The <code>TableLattice</code> works by performing N-dimensional Delaunay triangulation on the index vectors found in the provided OPAT file. Each unique index vector in the OPAT data becomes a vertex in this triangulation.</p>
<p>When you request data for a specific query point (an index vector):</p><ol type="1">
<li><b>Simplex Search</b>: The <code>TableLattice</code> first identifies the N-simplex (e.g., a triangle in 2D, a tetrahedron in 3D) within the Delaunay triangulation that encloses your query point. This is done using a "walk" algorithm through the triangulation.</li>
<li><b>Barycentric Coordinates</b>: Once the containing simplex is found, the barycentric coordinates of the query point with respect to the vertices of that simplex are calculated. Barycentric coordinates represent the query point as a weighted average of the simplex's vertices.</li>
<li><b>Interpolation</b>: The data associated with each vertex of the containing simplex (i.e., the <code>DataCard</code>s from the original OPAT file) are then interpolated using these barycentric weights. Currently, only <b>linear interpolation</b> is supported. This means each table within the <code>DataCard</code>s is interpolated element-wise.</li>
</ol>
<p>The result is a new <code>DataCard</code> containing tables where each value is an interpolated estimate corresponding to your query point.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Initialization</h2>
<p>To use <code>TableLattice</code>, you first need an <code><a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">opat::OPAT</a></code> object, which you can get by reading an OPAT file. Then, you construct a <code>TableLattice</code> object, passing the <code><a class="el" href="structopat_1_1_o_p_a_t.html" title="Structure to hold the entire OPAT file.">opat::OPAT</a></code> object to its constructor.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span>       <span class="comment">// For opat::readOPAT, opat::OPAT</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="table_lattice_8h.html">tableLattice.h</a>&quot;</span> <span class="comment">// For opat::lattice::TableLattice</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::string opat_filename = <span class="stringliteral">&quot;your_data.opat&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> opat_data = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(opat_filename);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize TableLattice with the loaded OPAT data</span></div>
<div class="line">    <a class="code hl_class" href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a> lattice(opat_data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// By default, Linear interpolation is used.</span></div>
<div class="line">    <span class="comment">// You can also specify it explicitly:</span></div>
<div class="line">    <span class="comment">// opat::lattice::TableLattice lattice_linear(opat_data, opat::lattice::InterpolationType::Linear);</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassopat_1_1lattice_1_1_table_lattice_html"><div class="ttname"><a href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a></div><div class="ttdoc">Represents a lattice structure for interpolating data from an OPAT object.</div><div class="ttdef"><b>Definition</b> tableLattice.h:110</div></div>
<div class="ttc" id="atable_lattice_8h_html"><div class="ttname"><a href="table_lattice_8h.html">tableLattice.h</a></div></div>
</div><!-- fragment --><p> During construction, the <code>TableLattice</code> will:</p><ol type="1">
<li>Extract all unique index vectors from the <code>opat_data</code>.</li>
<li>Build the Delaunay triangulation of these index vectors. This step can throw a <code>std::runtime_error</code> if, for example, there are insufficient or degenerate points for triangulation.</li>
</ol>
<h2><a class="anchor" id="autotoc_md18"></a>
Usage: Getting Interpolated Data</h2>
<p>Once the <code>TableLattice</code> is initialized, you can get interpolated data using its <code>get()</code> method. This method takes a <code><a class="el" href="class_float_index_vector.html">FloatIndexVector</a></code> (representing the point at which you want to interpolate) and returns an <code><a class="el" href="structopat_1_1_data_card.html" title="Structure to hold a DataCard, which contains multiple tables.">opat::DataCard</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opat_i_o_8h.html">opatIO.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="index_vector_8h.html">indexVector.h</a>&quot;</span>  <span class="comment">// For FloatIndexVector</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="table_lattice_8h.html">tableLattice.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::string opat_filename = <span class="stringliteral">&quot;your_data.opat&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_o_p_a_t.html">opat::OPAT</a> opat_data = <a class="code hl_function" href="namespaceopat.html#aca57fce2c7ef3e4714709b3d9507d4b0">opat::readOPAT</a>(opat_filename);</div>
<div class="line">    <a class="code hl_class" href="classopat_1_1lattice_1_1_table_lattice.html">opat::lattice::TableLattice</a> lattice(opat_data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the index vector for which you want to interpolate data</span></div>
<div class="line">    <span class="comment">// Ensure its dimension matches opat_data.header.numIndex</span></div>
<div class="line">    <a class="code hl_class" href="class_float_index_vector.html">FloatIndexVector</a> query_point({0.54, 0.07}); <span class="comment">// Example for a 2D OPAT</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the interpolated DataCard</span></div>
<div class="line">    <span class="comment">// This can throw exceptions (see Gotchas section)</span></div>
<div class="line">    <a class="code hl_struct" href="structopat_1_1_data_card.html">opat::DataCard</a> interpolated_card = lattice.<a class="code hl_function" href="structopat_1_1_data_card.html#af81bd2ef5fe5d57a368a07e9cf580197">get</a>(query_point);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now you can access tables from the interpolated_card as usual</span></div>
<div class="line">    <span class="comment">// For example, if your OPAT files contain a table tagged &quot;density&quot;:</span></div>
<div class="line">    <span class="comment">// const opat::OPATTable&amp; density_table = interpolated_card[&quot;density&quot;];</span></div>
<div class="line">    <span class="comment">// density_table.print();</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully retrieved interpolated data for &quot;</span> &lt;&lt; query_point &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aindex_vector_8h_html"><div class="ttname"><a href="index_vector_8h.html">indexVector.h</a></div><div class="ttdoc">Header file defining the FloatIndexVector class for handling floating-point index vectors.</div></div>
<div class="ttc" id="astructopat_1_1_data_card_html"><div class="ttname"><a href="structopat_1_1_data_card.html">opat::DataCard</a></div><div class="ttdoc">Structure to hold a DataCard, which contains multiple tables.</div><div class="ttdef"><b>Definition</b> opatIO.h:409</div></div>
<div class="ttc" id="astructopat_1_1_data_card_html_af81bd2ef5fe5d57a368a07e9cf580197"><div class="ttname"><a href="structopat_1_1_data_card.html#af81bd2ef5fe5d57a368a07e9cf580197">opat::DataCard::get</a></div><div class="ttdeci">const OPATTable &amp; get(const std::string &amp;tag) const</div><div class="ttdoc">Retrieves a table from the DataCard by tag.</div><div class="ttdef"><b>Definition</b> opatIO.cpp:284</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Gotchas and Considerations</h2>
<ul>
<li><b>Interpolation Type</b>: Currently, only <code>InterpolationType::Linear</code> is implemented and supported. Attempting to set or use other types will result in a <code>std::runtime_error</code>.</li>
<li><b>Out of Bounds/Convex Hull</b>:<ul>
<li>The <code>get()</code> method will throw a <code>std::out_of_range</code> exception if the query <code>indexVector</code> is outside the rectangular bounds defined by the minimum and maximum values of the original index vectors in each dimension.</li>
<li>More subtly, even if a point is within these rectangular bounds, it might be outside the <em>convex hull</em> of the original data points. If the <code>findContainingSimplex</code> method cannot find a simplex that encloses the query point (i.e., the point is outside the convex hull), it will also typically result in a <code>std::out_of_range</code> or <code>std::runtime_error</code> (e.g., if the walk algorithm fails to locate the point).</li>
<li><b>Resolution</b>: Ensure your query points are within the domain covered by the input OPAT file's index vectors.</li>
</ul>
</li>
<li><b>Dimensionality</b>: The query <code>indexVector</code> must have the same number of dimensions as the index vectors in the OPAT file (<code>opat_data.header.numIndex</code>). Mismatched dimensions will lead to a <code>std::invalid_argument</code> exception.</li>
<li><b>Degenerate Data</b>: If the index points in the OPAT file are degenerate (e.g., all points are collinear in 2D, or coplanar in 3D, preventing a valid N-dimensional triangulation), the <code>TableLattice</code> constructor might fail (throwing <code>std::runtime_error</code> from Qhull).<ul>
<li><b>Resolution</b>: Ensure your OPAT file contains a good distribution of index points suitable for N-dimensional triangulation.</li>
</ul>
</li>
<li><b>Performance</b>:<ul>
<li>The construction of <code>TableLattice</code> (building the Delaunay triangulation) can be computationally intensive for a very large number of unique index vectors or high dimensionality. However, this is a one-time cost.</li>
<li>The <code>get()</code> operation involves a walk through the triangulation and then barycentric calculations. The <code>TableLattice</code> caches the last found simplex, which can speed up queries for spatially coherent points.</li>
</ul>
</li>
<li><b>Error Handling</b>: Methods like <code>get()</code>, constructors, and <code>setInterpolationType()</code> can throw various exceptions (<code>std::out_of_range</code>, <code>std::invalid_argument</code>, <code>std::runtime_error</code>). It's good practice to wrap calls to these methods in <code>try-catch</code> blocks in production code if you anticipate potentially problematic inputs.</li>
<li><b>Dumping Triangulation</b>: For debugging or visualization, you can dump the triangulation structure: <code>cpp lattice.dumpTriangulationToAscii("points_output.txt", "simplices_output.txt"); </code></li>
</ul>
<p>The <code>TableLattice</code> provides a robust way to perform N-dimensional linear interpolation on OPAT data, extending the utility of your datasets.</p>
<hr  />
<hr  />
<h2><a class="anchor" id="autotoc_md22"></a>
2. Command-Line Interface (CLI) Usage</h2>
<p>The OPAT I/O library includes several CLI tools for inspecting and validating OPAT files. Below are the available tools and their usage:</p>
<h3><a class="anchor" id="autotoc_md23"></a>
2.1 <code>opatHeader</code></h3>
<p><b>Description:</b> Displays the header information of an OPAT file.</p>
<p><b>Usage:</b> </p><div class="fragment"><div class="line">opatHeader --file &lt;path_to_opat_file&gt;</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line">opatHeader --file example.opat</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
2.2 <code>opatInspect</code></h3>
<p><b>Description:</b> Displays the header and card catalog information of an OPAT file.</p>
<p><b>Usage:</b> </p><div class="fragment"><div class="line">opatInspect --file &lt;path_to_opat_file&gt;</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line">opatInspect --file example.opat</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
2.3 <code>opatVerify</code></h3>
<p><b>Description:</b> Verifies if a file is a valid OPAT file.</p>
<p><b>Usage:</b> </p><div class="fragment"><div class="line">opatVerify --file &lt;path_to_opat_file&gt;</div>
</div><!-- fragment --><p><b>Example:</b> </p><div class="fragment"><div class="line">opatVerify --file example.opat</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md27"></a>
Additional Notes</h1>
<ul>
<li>For more detailed examples and API documentation, refer to the header files (<code><a class="el" href="opat_i_o_8h.html" title="Header file for the OPAT I/O library, providing structures and functions for reading and manipulating...">opatIO.h</a></code>, <code><a class="el" href="index_vector_8h.html" title="Header file defining the FloatIndexVector class for handling floating-point index vectors.">indexVector.h</a></code>) and the source code.</li>
<li>Ensure that the OPAT file format adheres to the expected structure to avoid runtime errors.</li>
</ul>
<p>` </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
